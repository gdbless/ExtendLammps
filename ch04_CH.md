# 4 通过变量、数组和方法访问信息

在本章中，我们将描述如何使用内部 LAMMPS 变量和方法获取与 MD 模拟相关的物理量，例如原子的位置、速度和力。这些方法和变量被编码到前面章节中描述的类（位于 src 文件夹中）中。

我们将涵盖以下主题：

- 访问原子属性

- 映射局部和全局原子索引

- 请求近邻表

- 访问物理常数

- 从输入脚本中读取输入参数

在本章结束时，您将了解如何使用这些句柄访问基本的模拟数据，例如系统状态和粒子属性，以及如何使用适当的方法来协商 MD 中遇到的常见模拟场景。

## 技术要求
要执行本章中的说明，您只需要一个文本编辑器（例如，**Notepad++** 或 **Gedit**）。

你可以在这里找到本章使用的完整源代码：https://github.com/PacktPublishing/Extending-and-Modifying-LAMMPS-Writing-Your-Own-Source-Code

这是下载 LAMMPS 的链接：https://lammps.sandia.gov/doc/Install.html。LAMMPS GitHub 链接是 https://github.com/lammps/lammps，也可以在其中找到源代码。

## 在模拟运行期间访问原子属性
在本节中，我们将学习如何在模拟运行期间使用“Atom”类访问原子的属性。

`atom.cpp` 和 `atom.h` 中表示的 Atom 类提供了对各种原子属性的访问，包括原子类型、分子 ID、位置、速度和力。这些数量列在 atom.h 头文件中，如下所示：

<div align=center>
<img src=./ch04/fig4_1.jpg>
</div>

图 4.1 – atom.h 的代码片段

通过将此头文件导入到它们的 .cpp 文件中，可以从其他类访问这些数量：

```
#include "atom.h"
```

可以使用指向 `atom.h` 中数量的箭头运算符声明变量以读取这些数量。例如，如您在前面的屏幕截图中所见，要访问由 x 定义的原子在 `atom.h` 中的位置（*第 58 行*），我们使用以下行：

```
double **x = atom->x;
```

这里，** 表示 x 存储为二维数组，其中一维表示原子索引，另一维表示 x、y 和 z 三个坐标。要访问索引为 i 的原子的三个坐标并将它们存储为“x1”、“y1”和“z1”变量，我们可以键入以下内容：

```
double x1 = x[i][0];
double y1 = x[i][1];
double z1 = x[i][2];
```

虽然位置、速度和力等每个原子的向量存储在二维数组中，但原子类型和分子类型等每个原子的标量存储在一维数组中。此外，全局量（例如系统中原子类型的数量）存储为单个变量。以下几点显示了 atom.h 中选定数量的清单：

- `double **x = atom->x`：这会将原子的位置返回为 *x[i][w]*，其中 *i* 表示原子索引，w=0,1,2 表示分别为 x、y 和 z 坐标。

- `double **v = atom->v`：返回原子的速度为 *v[i][w]*，其中 *i* 表示原子索引，w=0,1,2 表示分别为 x、y 和 z 分量。

- `double **f = atom->f`：返回原子作用的总力为 *f[i] [w]*，其中 i 表示原子索引，w=0,1,2 表示分别为 x、y 和 z 分量。

- `int *type = atom->type`：这会将原子的原子类型返回为 *type[i]*，其中 *i* 表示原子索引；返回的值对应于在输入脚本或支持数据文件中初始化期间指定的原子类型。

- `tagint *molecule = atom->molecule`：这会将原子的分子 ID 返回为 *molecule[i]*，其中 *i* 表示原子索引。此命令对于识别属于同一分子的原子很有用。

- `bigint natoms = atom->natoms`：返回系统中原子的总数。

- `int nlocal = atom->nlocal`：返回属于执行此行的核心的拥有原子数。当使用多个核心时，每个核心只能操纵包含在其域中的原子或鬼原子。

- `int分子 = atom->molecular`：返回输入脚本中使用的原子样式类型，其中输出值 0,1,2 用于表示原子系统、分子系统和分子模板系统，分别。

- `int *num_bond = atom->num_bond`：这将返回原子的键数为 *num_bond[i]*，其中 *i* 表示原子索引。

- `tagint **bond_atom = atom->bond_atom`：这会将键合原子的索引返回为 *bond_atom[i][j]*，其中 *i* 表示原子索引，*j* 表示键索引。输出值是与原子 i 在其与索引 *j* 的键处键合的原子的索引。此外，输出原子索引对应于输入脚本和数据文件中指定的全局原子 ID，而不是本地原子索引。

atom 的 ID 可以用局部索引或全局索引来描述，在编写代码时需要妥善处理。这个概念将在下一节中更详细地描述。

## 映射原子索引

在输入脚本或输入脚本读取的数据文件中指定的原子 ID 被视为**全局**原子 ID，而不同的**本地**原子索引由范围从 0 到 (` nlocal-1`) 的处理器。

如*第 1 章，MD 理论和模拟实践*中所述，多核系统中的每个核都分配有一定数量的自有原子，用于执行计算。使用 Atom 类访问信息时，如前所述，必须使用本地索引作为输入，并且各个核心使用此索引来计算所需的输出。

我们使用以下命令将全局索引转换为本地索引，反之亦然：

- 从全局索引“G”转换为本地索引“L”：

    ```
    int L = atom->map(G);
    ```

- 从本地索引“L”转换为全局索引“G”：

    ```
    tagint *tag = atom->tag;
    int G = tag[L];
    ```

如果输入原子 ID 不存在，则 `atom->map()` 函数返回 -1。

在本节中，我们了解了各种原子属性和用于访问它们的各种数量，以及在全局索引和局部索引之间转换的代码。

在 MD 模拟期间，**近邻表**通常需要考虑原子与其邻居的相互作用，因此必须将其合并到读取原子属性的同一类中。在下一节中，我们将描述如何调用近邻表和识别邻居。

## 请求近邻表

在本节中，我们将学习如何初始化和访问单个原子的近邻表。

近邻表由“neigh_list.cpp”和“neigh_list.h”表示的“NeighList”类控制。当请求近邻表时，系统近邻表由 neighbour.cpp 生成，并且通过 `Neighlist` 类可以方便地访问近邻表的各种元素。

在pair样式的情况下，近邻表在`pair.h`中创建，并由子pair classes继承；描述如下：

<div align=center>
<img src=./ch04/fig4_2.jpg>
</div>

图 4.2 – pair.h 中的代码片段

`Pair:init_style()` 方法请求近邻表，如*第 3 章源代码结构和执行阶段*中的*图 3.6 所示。可以根据需要请求完整或一半的近邻表。在修复的情况下，“fix.h”父类不请求近邻表，因此个别子修复类需要在需要时请求它。在下面的屏幕截图中，我们展示了在 `fix_orient_fcc.cpp`（位于 `src/MISC` 文件夹中）中实现的近邻表请求：

<div align=center>
<img src=./ch04/fig4_3.jpg>
</div>

图 4.3 – 来自 fix_orient_fcc.cpp 的代码片段显示了 init() 和 init_list() 方法

正如您在前面的屏幕截图中看到的，在 *line 221* 上，`init()` 方法显示了请求，并且 *lines 222* 到 *225* 指定了适用于修复的完整近邻表，而不是一半适用于配对样式的近邻表。然后，需要引入一个 `init_list()` 方法来获取近邻表指针，并使用一个名为 `list` 的占位符。

获得指针后，通常会访问以下近邻表元素：

- `int inum = list->inum`：返回已确定近邻表的原子数。

- `int *ilist = list->ilist`：这会将原子的局部索引返回为 `ilist[ii]`，其中 ii 是根据其在 0 和 (`inum-1`) 之间指定的同一原子的索引在近邻表数组中的位置。

- `int *numneigh = list->numneigh`：返回每个原子的邻居数为`numneigh[i]`，其中`i`是本地原子索引。

- int **firstneigh = list->firstneigh：返回相邻原子的局部索引为`firstneigh[i][j]`，其中`i`代表中心原子局部索引，`j`代表相邻原子指数。`j` 索引不是本地原子索引，而是指定在 0 和 (`numneigh[i]-1`) 之间，即根据它在近邻表中的位置。输出值是中心原子“i”的相邻原子“j”的局部原子索引。

下图说明了上述近邻表的架构及其数量：

<div align=center>
<img src=./ch04/fig4_4.jpg>
</div>

图 4.4 – 显示 inum、ilist、numneigh 和 firstneigh 数量的近邻表架构

如上图所示，当考虑一个核心中所有拥有的原子并计算它们与其近邻表中的原子的交互时，一个常见的策略是遍历所有存在近邻表的中心原子 inum并迭代地遍历每个中心原子的邻居。

在 inum 的第一个循环（索引为 `ii`）中，提取每个中心原子的局部原子索引（`i`）（`i = ilist[ii]`），原子的邻居数（`jnum `) 被检索 (`jnum = numneigh[i]`)，并创建一个邻居数组 (`jlist`) (`jlist = firstneigh[i]`)。

位于第一个循环内的第二个循环（索引为“jj”）遍历原子“i”的所有邻居 jnum，并提取每个邻居的局部原子索引（“j”）（“j = jlist[jj]”） . 实际上，`jlist[jj]` 返回与`firstneigh[i][jj]` 相同的输出。

以下代码行说明了此过程：

<div align=center>
<img src=./ch04/fig4_5.jpg>
</div>

图 4.5 – 使用注释访问近邻表（左）的典型代码（右）

如您所见，通过这种方式，所有具有近邻表的原子都被计算在内，并且它们的邻居被识别出来。此外，它们的原子索引可用于访问原子属性，例如原子位置，以计算中心原子与其每个相邻原子之间的距离。

在本节中，我们了解了近邻表的结构以及如何在对样式中调用它们并修复样式。

除了动态模拟功能之外，LAMMPS 还提供对原子模拟中常用的物理常数存储库的访问。这些常量在源代码中是硬编码的，我们将在下一节中描述它们。

## 访问物理常量
 
LAMMPS 中使用的不同单位的物理常数（例如，SI、“real”和“metal”）可以使用 `force.h` 中的箭头运算符获得。以下屏幕截图显示了这些常量的列表：

<div align=center>
<img src=./ch04/fig4_6.jpg>
</div>

图 4.6 – force.h 的屏幕截图，显示了用于实现物理常数的变量

正如您在前面的屏幕截图中看到的，“force.h”仅包含代表各种物理常数的变量名称。这些常量的数值在 `update.cpp` 中提供，它导入 `force.h` 并在 `Update::set_units()` 方法中为这些变量赋值，如以下屏幕截图所示：

<div align=center>
<img src=./ch04/fig4_7.jpg>
</div>

图 4.7 – update.cpp 中的代码片段，将数值分配给表示物理常数的变量

当从其他类访问它们时，通过 `Update::set_units()` 方法检索正确单元中的常量。例如，以下代码行将 Boltzmann 常数返回到 Boltz 变量：

```
#include “force.h”
doubleboltz = force->boltz；
```

单位不需要在类中指定，将由 LAMMPS 输入脚本中使用的单位自动确定。

到目前为止，我们已经讨论了访问源代码生成的数量。接下来，我们将讨论使用“force.cpp”类中提供的各种方法解析在 LAMMPS 输入脚本中输入的参数。

## 从输入脚本中读取参数

在本节中，我们将学习解析用户在 LAMMPS 输入脚本中输入的参数。在*第 3 章，源代码结构和执行阶段*中，讨论了 `input.cpp` 在解析输入脚本命令的第一个单词中的作用。在本节中，我们将讨论负责解析与各种命令相关的用户输入量的方法。

与各种样式相关的用户输入参数，例如对样式中的数字对系数值和修复中的力值，由相应的类或其父类从 LAMMPS 输入脚本中解析。

**重要的提示**：
这些方法位于 LAMMPS 稳定版本 **3Mar20** 中的 `force.cpp` 中，而它们已移至稳定版本 **29Oct20** 中的 `utils.cpp` 中。有关版本兼容性的更多信息，请参阅附录 D。

这些量的解析由“force.cpp”类通过下面讨论的几种方法执行：

- 这是 `Force::numeric()` 方法的屏幕截图，该方法从输入脚本中读取浮点数：

<div align=center>
<img src=./ch04/fig4_8.jpg>
</div>

图 4.8 – force.cpp 中显示 numeric() 方法的代码片段

正如您在前面的屏幕截图中看到的那样，当 `Force::numeric()` 方法读取文本的输入字符串时，如果输入为空或空（*line 940*），它会返回错误并验证该字符串仅包含数字和 +、-、.、e 和 E 符号（*第 945* 到 *951* 行）。验证后，字符串将被解析为浮点数（*第 954 行*）。

- 同样，`Force::inumeric()` 方法从手动输入的文本中读取整数：

<div align=center>
<img src=./ch04/fig4_9.jpg>
</div>

图 4.9 – force.cpp 中显示 inumeric() 方法的代码片段

此方法遵循与 `Force::numeric()` 类似的一组规则，除了它只允许输入字符串中的 + 和 - 符号（*第 973* 到 *977* 行）。验证后的字符串以整数形式返回（*line 980*）。

- 其他方法包括 `Force::bnumeric()` 和 `Force::tnumeric()`，它们分别读取大整数（例如系统中的原子数）和标记整数（例如原子和分子 ID） ; 这在 `lmptype.h` 中有更详细的描述。当读取必须限制为介于 1 和指定原子类型数之间的整数的原子类型时，可以使用 `Force::bounds()` 方法来验证输入字符串：

<div align=center>
<img src=./ch04/fig4_10.jpg>
</div>

图 4.10 – force.cpp 中显示 bounds() 方法的代码片段

如 LAMMPS 手册 (https://lammps.sandia.gov/doc/) 中所述，此方法在以对样式（*第 873* 到 *889* 行）定义原子类型时适应使用 * 符号。原子类型的正确下限和上限以 `nlo` 和 `nhi` 整数形式返回，如果原子类型超出允许范围，或者第一个原子类型大于第二个原子类型（ *第 891 行* 到 *892*）。

**重要的提示**：
`force->` 方法用于 LAMMPS 版本 **3Mar20**，而 `utils::` 方法用于 **29Oct20** 版本。有关详细讨论，请参阅*附录 D*。

- `pair_morse.cpp` 的以下摘录显示了用于从输入脚本中读取有关 `pair style Morse` 参数的一些上述方法（当我们分析配对样式时，将更详细地描述 Morse 对样式及其参数在*第 5 章，了解配对样式*）：

<div align=center>
<img src=./ch04/fig4_11.jpg>
</div>

图 4.11 – 来自 pair_morse.cpp 的代码片段，显示了由 force.cpp 中的方法解析的输入参数

正如您在前面的屏幕截图中看到的，*第 184* 到 *185* 行使用 `force->bound()` 方法来读取在它们之间实现了这种对样式的原子类型。在 `force->bounds()` 方法的参数中，`arg[0]` 和 `arg[1]` 指的是输入脚本中输入的第一个和第二个原子类型。

*第 187* 到 *189* 行使用 `force->numeric()` 方法从原子类型之后输入的三个连续参数中读取浮点参数 `d0_one`、`alpha_one` 和 `r0_one` . 在这些方法中用作第一个参数的 `FLERR` 标志在 `pointers.h` 中定义（*第 34 行*）：

```
#define FLERR __FILE__,__LINE__
```

这个标志将文件名和行号组合成一个参数，它解释了每个方法中所需的前两个参数。

在执行需要用户输入值的样式（例如，对样式或修复）时，相关源代码会采用适当的方法从输入脚本行中的正确位置解析这些值。这个过程将在后面的章节中分析这些风格时更详细地说明。

在本节中，我们了解了用于解析输入脚本参数的方法。当我们涉及需要从 LAMMPS 脚本输入的类时（例如，配对样式、计算和修复），这些方法将经常遇到。

在下一节中，我们将概述在 LAMMPS 中合并新数据类型的过程，用于扩展解析和处理输入提供的功能。

## 合并新的数据类型

当标准 C++ 存储库中不存在某种数据类型时，可以通过在 `lmptype.h` 中适当地定义它来创建并合并到 LAMMPS 源代码中。例如，前面在 `tagint bond_atom = atom->bond_atom` 中描述的 `tagint` 数据类型是 int 数据类型的变体。此 tagint 数据类型已在 `lmptype.h` 中定义，如以下屏幕截图所示：

<div align=center>
<img src=./ch04/fig4_12.jpg>
</div>

图 4.12 – lmptype.h 中显示 tagint 和 bigint 数据类型声明的代码片段

如您所见，C++ 中内置的 `typedef` 函数可用于在 `lmptype.h` 中声明具有自定义属性的新数据类型，并且可以在其余源代码中访问这些数据类型。

通常， int 默认为 4 字节（32 位）数据类型，这意味着它可以容纳高达 $2^{31}$ 的 10 位数字。有时，如果模拟系统必须容纳更大的数字，我们可以使用 typedef 将 `int`（32 位）和 `int64_t`（64 位）数据类型别名为 tagint 和 bigint 数据类型，使用 `lmptype.h 中的宏`。

 
如*图 4.12* 所示，`LAMMPS_SMALLBIG` 定义（*第 77 行*）将 `smallint`、`imageint` 和 `tagint` 数据类型声明为 int 类型，而它声明了 `bigint` 数据类型从 `int64_t` 类型开始（*第 79* 到 *82* 行）。类似地，`LAMMPS_BIGBIG` 定义（*第 109 行*）将`smallint` 声明为`int` 类型，`imageint`、`tagint` 和`bigint` 声明为`int64_t` 类型（*第 111 行* 到*114*)。

在编译期间，可以分别使用 CMake 和 Make 中的 `–DLAMMPS-SIZES=value` 或 `LMP_INC = -DLAMMPS_SMALLBIG` 选项来选择所需的定义（请参阅 *附录 A，使用 CMake 构建 LAMMPS* 中的详细信息）。

下表列出了编译期间选择的 `LAMMPS_BIGBIG`、`LAMMPS_SMALLBIG` 和 `LAMMPS_SMALLSMALL` 定义所容纳的范围（*第 109*、*77* 和 *140*​​ 行）：

<div align=center>
<img src=./ch04/table4_1.jpg>
</div>

表 4.1 – lmptype.h 中可用定义所包含的原子数范围列表、时间步数、原子 ID 和图像标志值

图像标志值跟踪原子通过每个维度中的周期性边界行进的模拟框长度的倍数（参见*第 1 章，MD 理论和模拟实践*）。考虑到三个 *(x, y, z)* 维度，可用位的数量由三个维度平均共享。

因此，如果有 32 位可用（如在 `LAMMPS_SMALLBIG` 和 `LAMMPS_SMALLSMALL` 中），每个维度都分配有 10 位，这实际上允许 $2^{10}$ 整数范围，从 $-2^9$ 到 ( $2^9-1$)。类似地，对于“LAMMPS_BIGBIG”，可用的 64 位在每个维度中分为 21 位的份额，其范围从 $-2^{20}$ 到 ($2^{20}-1$) 整数

LAMMPS 手册 (https://lammps.sandia.gov/doc/Library_utility.html) 中提供了更详细的讨论。

在本节中，已经解释了自定义数据类型的声明和各种定义所跨越的范围。在访问源代码中的信息的上下文中，本节中描述的主题将帮助用户理解相关的限制。

## 概括
在本章中，我们描述了在模拟运行期间使用内置方法访问相关 MD 信息的不同方式，这对用户编写自定义代码时很有用。我们没有提供可以访问的数量的详尽列表，当我们在接下来的章节中详细分析样式时，我们会遇到其他变量和方法，这些变量和方法将在遇到时进行解释。

在下一章中，我们将使用迄今为止涵盖的概念来分析样本对样式，以实际了解这些样式如何读取、计算和生成输出。由于添加到 LAMMPS 的大多数新功能都是通过修改现有功能创建的，因此在实现新的 LAMMPS 功能时，现有样式的概述将特别有用。

## 问题

1. 变量名前面的*和**符号对它们的内存分配意味着什么？

2. 在近邻表请求期间通常创建的 firstneigh 数组中包含哪些信息？

3. 什么时候应该使用 `force->inumeric()` 方法而不是 `force->numeric()` 方法来解析来自脚本的输入？