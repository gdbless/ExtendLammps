# 1 MD理论和模拟实践

本章介绍分子动力学 (MD) 背后的理论和一些常见的模拟实践。从牛顿定律开始，我们概述了点粒子和刚体动力学背后的物理学，讨论了迭代更新和温度的相关性，最后列出了计算实践。

在本章中，我们将介绍以下主题：
- 介绍 MD 理论

- 了解点粒子的动力学

- 使用 Velocity Verlet 算法执行迭代更新

- 了解旋转运动

- 检查粒子的温度和速度分布

- 实施 MD 模拟实践，包括截止、周期性边界和近邻列表

在本章结束时，您将了解 MD 软件中实现的理论基础。

## 技术要求
你可以在这里找到本书中使用的完整源代码：https://github.com/PacktPublishing/Extending-and-Modifying-LAMMPS-Writing-Your-Own-Source-Code

## 介绍 MD 理论
MD 基于在所需时间段内模拟单个粒子轨迹，以分析整个固体、液体或气体状态的粒子系统的时间演变。根据牛顿经典动力学定律，每个粒子（通常是一个原子）都可以在空间中穿行，其中一个时间点的原子位置、速度和加速度用于计算不同时间点的相应运动学量. 对于系统中的每个原子，该过程在足够长的时间间隔内重复，并且原子的最终配置表明系统在所述时间间隔内的时间演化。

典型的 MD 模拟仅限于研究由 $10^2$ 到 $10^6$ 范围内的原子组成的原子系统，在纳秒的常规时间尺度上占据一个长度为纳米级的模拟盒。当系统能够代表相应宏观系统的时间演化时，这种微观系统的 MD 模拟是相关的。

以下部分简要介绍了 MD 背后的理论。如需更详细的了解，建议您参考有关 MD 理论的专门文献（Michael P. Allen 和 Dominic J. Tildesley 的计算机模拟液体，以及 Daan Frenkel 和 Berend Smit 的理解分子模拟）。

## 理解点粒子的动力学
点粒子随时间 $t$ 的轨迹 $\overrightarrow{r}(t) = (x(t),y(t),z(t))$ 由其质量 $m$ 和净力 $ 计算得出\overrightarrow{F_{net}}$ 使用牛顿方程，如下所示：
$$\overrightarrow{F_{net}}=m\overrightarrow{\ddot{r}}(t)$$
$\overrightarrow{F_{net}}$ 由作用在粒子上的所有力的总和确定。在相互作用的粒子系统中，作用在一对粒子之间的力 $\overrightarrow{F}$ 可以由势能函数 $V(\Delta{x},\Delta{y},\Delta {z})$。这里，$(\Delta{x},\Delta{y},\Delta{z})$ 是指向我们正在计算 $\overrightarrow{F}$ 的粒子的位移向量（使用以下等式）并且源自该对中的另一个粒子（如图 1.1 所示）：
$$\overrightarrow{F} = -\nabla{V}(\Delta{x},\Delta{y},\Delta{z})$$

这给了我们 $\overrightarrow{F}=(F_x,F_y,F_z)$ 的三个分量。$(x)$ 力分量如下：
$$F_x=-\frac{dV}{dr}\cdot\frac{\Delta{x}}{r}$$
$(y)$ 力分量由以下公式计算：
$$F_x=-\frac{dV}{dr}\cdot\frac{\Delta{y}}{r}$$
$(z)$ 力分量由以下公式给出：
$$F_x=-\frac{dV}{dr}\cdot\frac{\Delta{z}}{r}$$
这里，$r=|(\Delta{x},\Delta{y},\Delta{z})|$ 是粒子对之间的距离。根据牛顿第三定律，作用在对中另一个粒子上的力分量大小相同，符号相反。

下图说明了这个概念，使用两个粒子通过 $V(x)=4\epsilon[(\frac{\sigma}{x})^{12}-( \frac{\sigma}{x})^6]$，其中 $\epsilon$ 代表井深，$\sigma$ 代表势为零的位置：

<div align=center>
<img src='fig1_1.png'>
</div>

图 1.1 - 两个一维粒子通过 Lennard-Jones 势相互作用 $V(x)=4\epsilon[(\frac{\sigma}{x})^{12}-(\frac{\sigma}{x} )^6]$

在这个图中，如果我们想计算粒子 2（位于 $x=|\Delta{x}|$）作用在粒子 1（位于 $x=0$）上的力，那么我们使用 $F_{x1 }=-\frac{dV}{dx}\frac{(-|\Delta{x}|)}{|\Delta{x}|}$。随后，作用在粒子 2 上的反作用力由 $F_{x2}=-\frac{dV}{dx}\frac{(-|\Delta{x}|)}{|\Delta{x}|}$ 给出。

由于势能函数通常表示为 r 的函数，我们之前看到的表达式使得计算力分量更方便。通过与系统中所有粒子的相互作用作用在单个粒子上的力的总和给出了净力，如下所示：
$$\overrightarrow{F_{net}}=\sum_{all \ pairs}{\overrightarrow{F}}=-\sum_{all \ pairs}{\nabla V}$$
总之，我们获得了三个方程来求解 $𝑥(𝑡)$、$y(𝑡)$ 和 $z(𝑡)$。$x(t)$ 方程如下：
$$\ddot{x}=-\frac{1}{m}\sum_{all \ pairs}{(\frac{dV}{dr}\cdot\frac{x}{r})}$$
$y(t)$ 方程由以下公式给出：
$$\ddot{y}=-\frac{1}{m}\sum_{all \ pairs}{(\frac{dV}{dr}\cdot\frac{y}{r})}$$
$z(t)$ 方程由以下公式给出：
$$\ddot{z}=-\frac{1}{m}\sum_{all \ pairs}{(\frac{dV}{dr}\cdot\frac{z}{r})}$$

这些值用于生成粒子在所需时间间隔内的完整轨迹。对系统中的所有粒子重复此过程，以在相同的时间间隔内产生完整的系统时间演化。


## 使用 Velocity Verlet 算法执行迭代更新
随着粒子在系统中随着时间的推移移动，分离会相应地发生变化，从而导致上一节中描述的导数发生变化——也就是说，力变得与时间相关。因此，轨迹在被称为时间步长 $(\Delta t)$ 轨迹的小时间增量上更新，在大量时间步长上，可以获得完整的轨迹。

保持小时间步长的目的是确保粒子的位置不会发生剧烈变化，从而节省系统中的能量。对于原子质量，特别是在存在来自分子键、角度和二面角的力的情况下，通常采用大约 1 飞秒的时间步长。

使用小时间步长的一个优点是净力 $F_{net}$ 可以近似为在时间步长的持续时间内保持不变。因此，以时间步长迭代更新轨迹的运动方程变为：
$$x(t+\Delta t)=x(t)+v_x(t)\Delta t + \frac{1}{2}\frac{F_{net,x^(t)}}{m}\Delta t^2$$
$$y(t+\Delta t)=y(t)+v_y(t)\Delta t + \frac{1}{2}\frac{F_{net,y^(t)}}{m}\Delta t^2$$
$$z(t+\Delta t)=z(t)+v_z(t)\Delta t + \frac{1}{2}\frac{F_{net,z^(t)}}{m}\Delta t^2$$

这里，$(v_x(t),v_y(t),v_z(t))$ 表示粒子的速度向量，其分量通过以下方式迭代更新：
$$v_x(t+\Delta t)=v_x(t) + \frac{1}{2}[\frac{F_{net,x^(t)}}{m}+\frac{F_{net,x ^(t+\Delta t)}}{m}]\Delta t$$
$$v_y(t+\Delta t)=v_y(t) + \frac{1}{2}[\frac{F_{net,y^(t)}}{m}+\frac{F_{net,y ^(t+\Delta t)}}{m}]\Delta t$$
$$v_z(t+\Delta t)=v_z(t) + \frac{1}{2}[\frac{F_{net,z^(t)}}{m}+\frac{F_{net,z ^(t+\Delta t)}}{m}]\Delta t$$

这里，$[ ]$ 中的项表示每个维度的平均加速度，使用时间 t 的加速度和以下迭代计算得出，$(𝑡 + \Delta 𝑡)$。这被称为 **Velocity Verlet 算法**，与在单个时间点使用加速度的算法（例如，**Euler 算法**）相比，它大大减少了长时间模拟期间的错误。此外，Velocity Verlet 算法能够以足够小的时间步长在舍入误差内保存能量和动量，这与欧拉算法不同，欧拉算法会导致能量随时间无限增加。

实际上，每个粒子的位置和速度在每次迭代时都被制成表格，如下表所示：

<div align=center>
<img src='table1_1.png'>
</div>

表 1.1 - 显示每个粒子的位置和速度向量的迭代更新顺序的表

该表显示了点粒子的迭代更新序列，这些点粒子经历了没有任何旋转分量的线性运动。对于非点对象（例如刚体），必须同时结合线性和旋转运动，以便对其动力学进行适当处理。与线性运动类似，刚体的旋转运动可以使用类似的算法迭代更新，如下所述。


## 了解旋转运动
刚体通常用于表示具有非活动振动自由度的分子。在刚体中，所有组成原子的位置相对于刚体坐标是固定的。假设来自键、角、二面角和不正确的分子内力不会造成刚体的任何变形。因此，就 MD 而言，可以忽略刚体中的所有分子内力。施加在刚体中任何组成原子上的任何力都作用在整个刚体上。除了改变其线速度外，该力还可以在刚体上产生扭矩并改变其角动量和角速度。由 N 个粒子组成的刚体 $\overrightarrow{F_{tot}}$ 上的总力使用以下公式计算：
$$\overrightarrow{F_{tot}}=\sum_{i=1}^{N}{(\overrightarrow{F_i})}$$
使用从中心测量的粒子 $i$ 的位移向量 $\overrightarrow{r_i}=(x_i,y_i,z_i)$
以刚体的质量为原点，刚体的力矩$\overrightarrow{\tau}$由下式计算
以下公式：
$$\overrightarrow{\tau}=\sum_{i=1}^{N}{(\overrightarrow{r_i}\times{\overrightarrow{F_i}})}=\sum_{i=1}^{N} {(y_iF_{zi}-z_iF_{yi},z_iF_{xi}-x_iF_{zi},x_iF_{yi}-y_iF_{xi})}$$

刚体的角动量 $\overrightarrow{L}$ 是使用 Velocity Verlet 算法从 $\tau$ 的时间积分得到的，如下：
$$\overrightarrow{L}(t+\Delta t)=\overrightarrow{L}(t)+\frac{1}{2}[\overrightarrow{\tau}(t)+\overrightarrow{\tau}(t+ \Delta t)]\Delta t$$

刚体的角速度 $\overrightarrow{\omega}$ 是通过两步过程从 $\overrightarrow{L}$ 使用半时间步长 $(t+\frac{1}{2 }\Delta t)$，以及全时间步长 $(t+\Delta t)$ 的第二步，这将在第 7 章“了解修复”中分析刚体动力学时更详细地描述。此处说明了该过程：
$$I\overrightarrow{\omega}(t+\frac{1}{2}\Delta t)=\overrightarrow{L}(t+\frac{1}{2}\Delta t)$$
$$I\overrightarrow{\omega}(t+\Delta t)=\overrightarrow{L}(t+\Delta t)$$

这里，*$I$* 是刚体的转动惯量张量。

对于点粒子或刚体系统，平均动能和平均速度或角速度由系统温度决定。因此，在模拟分​​子系统时，充分控制温度通常是必不可少的。下一节讨论由温度决定的分子模拟的特征。


## 检查粒子的温度和速度分布
在恒定温度 T 下处于热平衡的系统的特征在于它的 **Maxwell-Boltzmann 速度分布**。根据这个分布，给定质量为 m 的粒子系统在单个方向 $i$（可以是 $x$,$y$,$z$）上的速度概率分布 $f(v_i)$由**高斯函数**，如图 1.2 所示：

<div align=center>
<img src='fig1_2.png'>
</div>

图 1.2 – Maxwell-Boltzmann 速度分布（左）和速度分布（右）

上图是针对同一系统在三个不同温度 $T3>T2>T1$ 下绘制的。

取决于质量和温度的相应函数形式如下所示：
$$f(v_i)=\sqrt{\frac{m}{2\pi k_BT}exp(-\frac{mv_i^2}{2k_BT})}$$

这里，$k_B$ 是玻尔兹曼常数。该分布的平均值为 $\mu=0$，标准差为 $\sigma=\sqrt{\frac{k_BT}{m}}$。高斯曲线的形状由 $\frac{m}{T}$ 的比率决定。速度向量$(v_x,v_y,v_z)$的速度分布由下式给出：
$$f(v_x,v_y,v_z)=f(v_x)f(v_y)f(v_z)=(\frac{m}{2\pi k_BT})^{\frac{3}{2}}exp[ -\frac{m(v_x^2+v_y^2+v_z^2)}{2k_BT}]$$

在球坐标中，这个分布可以用速度表示如下：
$$f(v)=\sqrt{\frac{2}{\pi}}(\frac{m}{k_BT})^{\frac{3}{2}}v^2\exp[-\frac {mv^2}{2k_BT}]$$

这是 Maxwell-Boltzmann 速度分布，也称为 **Rayleigh 分布**。速度分布的形状随温度变化，如图 1.2 所示，峰值速度随温度增加。在较高温度下速度分布较宽，并且速度分布在较高温度下显示较大的峰值速度。在分子模拟中控制温度的算法必须考虑到前面关于粒子速度的特征。

到目前为止，已经讨论了决定 MD 模拟操作的概念。这些概念是通过代码在计算环境中实现的，这些代码将在后面的章节中讨论。在下一节中，我们将讨论 MD 模拟中常见的相关计算概念，这些概念通常用于提高模拟性能。


## 实施 MD 模拟实践
为了实现计算效率高的 MD 模拟和模拟现实原子系统，采用了许多标准模拟实践。用户可能会在典型的 **Large-scale Atomic/Molecular Massively Parallel Simulator (LAMMPS)** 脚本中发现这些实践，因此在深入研究 LAMMPS 源代码之前熟悉这些概念会很有帮助。在本节中，我们将简要讨论其中的一些实践（详细信息可在*介绍 MD 理论*部分中提到的 MD 教科书中获得）。

### 对电位截止
如果希望电位在截止点处恰好达到零，则可以通过计算在截止点 $r=r_{cut}$ 处的电位 $V(r)$ 来使用偏移量 ($V_{offset}$)，即是 $V_{offset}=V(r_{cut})$ 。然后可以从原始电位中减去这个偏移量，以保证在截止处为零值，即 $V(r)\rightarrow V(r)-V_{offset}$。总之，具有偏移的势能改变系统势的值，但不会改变力，因为 $V_{offset}$ 是一个常数项，在微分时产生零力贡献。

大多数对势函数被定义为渐近地接近零势——例如，Lennard-Jones 函数作为分离的*逆六次方*接近零。对于彼此远离的粒子，这意味着它们之间存在一些小但非零的势能，这在模拟环境中可能可以忽略不计，但仍会增加数值计算开销。

因此，一种常见的做法是对对电位采用截止距离，超过该距离，则假定相互作用为零。在潜在值足够小的分离处选择截止值，以免通过忽略与位于截止值之外的近邻的交互而产生重大错误。在模拟运行期间，仅考虑位于粒子截止半径内的相邻粒子进行力或势计算，从而减少计算时间。

### 周期性边界条件
模拟系统通常由代表较大系统的小单元组成——例如，金属晶格的纳米晶体表示。在这样的系统中，通常可以假设整个系统由模拟框的许多复制组成。1912 年，Born 和 von Karman 提出了**周期性边界条件**的实现，它可以从模拟盒开始模拟连续复制的系统。假设模拟盒的每个壁（即边界）与在相同位置包含相同原子的相同模拟盒相邻。实际上，盒子的每一面墙都通向模拟盒子的复制品，其中包含与模拟盒子中相同原子的图像。在每次迭代中，随着模拟框中的原子位置更新，副本中的图像原子相应地更新。下图显示了这个模拟框：

<div align=center>
<img src='fig1_3.png'>
</div>

图 1.3 – 没有（顶部）和（底部）周期性边界的 2D 模拟框

在此图中，我们看到以下内容：

- 顶部：2D 模拟框的快照，包含四个粒子（索引从 **1** 到 **4**），没有周期性边界。

- 底部：在所有方向具有周期性边界的同一模拟框产生 8 个包含图像原子（$dashed circles$）的副本（3D 中的 26 个副本）。在
每次迭代，所有副本都会通过复制中央模拟框中的粒子来进行相同的更新。

这样，围墙边界就被消除了，任何通过墙离开模拟框的原子都将自动重新穿过对面的墙，从而节省了原子的数量并模拟了原子的连续运动。此外，模拟盒中的原子被允许与位于复制品中的图像原子相互作用，确保靠近壁的原子不会仅仅因为它们远离盒中心而被视为几乎没有近邻的边缘原子。

在*图 1.3* 中，在没有周期性边界的情况下，观察到右上角的粒子 3 远离粒子 **1** 和 **4**，并且会与这些粒子发生减少或零相互作用粒子。相比之下，当实现周期性边界时，粒子 3 的位置非常接近粒子 **1** 和 **4** 的图像。

随后，粒子 3 能够与位于其周围各个方向的其他粒子相互作用，就好像它被包含在一个连续的、无界的模拟框中一样。同时，相互作用的一致性要求粒子 3 与模拟框中的图像或原始粒子相互作用，但不能同时与两者相互作用，通过将模拟框的边长设置为至少两倍来实现原子之间的对势截止距离。这个要求被称为**最小图像约定**，它保证了对潜在交互不会重复计算。

*长程静电势*衰减比许多其他相互作用慢得多（作为分离的倒数），因此需要不成比例的长截止和相应的大模拟框来模拟传统的对电位。为了规避这个问题，与图像原子的静电相互作用通过 Ewald 求和（或相关的粒子网格方法）求和，将计算划分为 *实空间* 分量和 *倒易空间分量*。这样，不需要截止，但需要周期性边界以确保总和收敛。

当一个原子离开模拟框并且其图像从框的另一侧进入时，原子坐标可以超出模拟框坐标。这是使用包裹和展开坐标的概念来解释的，其中展开坐标表示未调整的原子坐标，包裹坐标表示通过重置为重新进入壁的坐标而调整的坐标。

在 LAMMPS 中，轨迹输出文件可能包含一个 **image flag** 以跟踪包裹和展开的坐标。当一个原子沿任意维度的正方向离开模拟框时，该轴对应的图像标志将增加一。因此，如果原子沿负方向退出，则图像标志减一。因此，原子的图像标志乘以相应的模拟框边长可用于从包裹坐标转换为展开坐标。


### 近邻列表
原子仅与位于截止半径内的近邻相互作用，并且通过计算它们与所考虑原子的距离来识别这些近邻。对于 N 个原子的系统，这可能会导致计算 $\frac{1}{2}(N^2-N)$ 对原子之间的距离。为了减少计算开销，对于每个原子，一个近邻子集被选择到一个**近邻列表**中（由 Verlet 在 1967 年建议），并且只有这些入围的近邻用于计算与原子的交互。

在模拟开始时，通过标记位于其截止范围内或短缓冲区宽度内的所有相邻原子，为系统中的每个相互作用原子构建一个近邻列表，称为**趋肤宽度**（显示在 *图 1.4*)。如果原子没有以极快的速度行进，那么只有在某个迭代中位于截止或皮肤（即近邻列表成员）内的原子可以预期在下一次迭代中位于截止半径内，并且它可以预期，在一次迭代的空间中，先前位于皮肤外的原子将无法穿过截止半径内。

这样，近邻列表通过重用来自先前迭代的信息来排除位于足够远的原子，因此这减少了计算近邻距离的计算时间。该过程如下图所示：

<div align=center>
<img src='fig1_4.png'>
</div>

图 1.4 – 中心原子径向 $r_{cutoff}$ 距离和趋肤宽度 $r_s$ 的图示（黑点）

在任何时间步长，位于 $r_s$ 内的原子都包含在中心原子的近邻列表中，而只有位于 $r_{cutoff}$ 内的原子与中心原子相互作用。在下一次迭代中，在识别可以与中心原子相互作用的原子时，只考虑在近邻列表中标记的原子，并且可以根据原子的位移重建近邻列表。

通常，近邻列表不必在每次迭代时都重建，重建的间隔可以由用户定义。此外，一种常见的做法是仅当原子自上次近邻列表构建以来已经行进超过趋肤宽度的一半时才进行重建。这也意味着更大的趋肤宽度需要更少的近邻列表构建，代价是在每次迭代中每个列表包含更多数量的近邻。

趋肤宽度可以独立于截止距离来指定，并且通常根据时间步长和预期的粒子速度来选择。在下限，蒙皮宽度应该是迭代中粒子预期的最大位移的两倍。在 LAMMPS 中，如果一个原子能够在一次迭代中穿过趋肤宽度，则相关的近邻列表会经历一个**危险构建**，因此原子的丢失会导致力计算错误和违反能量守恒。如果检测到危险构建，则需要重建近邻列表以纠正此问题。

当使用近邻列表计算一对原子之间的相互作用力时，可以根据牛顿第三定律为一对原子中的两个原子分配相等且相反的力。可以使用 *full-neighbor* 列表启用此等效性，而可以使用半近邻列表禁用它。虽然全近邻列表降低了计算成本，但在不适用相等和相反力的模拟中，半近邻列表可能是首选。

### 处理器通信
现代并行计算机有两种主要形式：**共享内存**机器，其中多个处理器（通常称为内核）访问相同的内存；和**分布式内存**机器，其中处理器（通常称为**节点**）无法访问指定给另一个处理器的内存。现代高性能计算设施都基于混合架构。一个节点由多个核心组成，许多节点组合起来组成一个超级计算机。这种架构还导致了在节点和核心之间分配工作负载和分配任务的问题。

在 MD 的上下文中，解决任务分配问题的一种策略是**空间分解**，它将模拟框分成相等的部分，并将位于每个部分的原子分配给不同的核心，如下所示：

<div align=center>
<img src='fig1_5.png'>
</div>

图 1.5 –（左）计算模拟框中每个原子轨迹的单个处理核心。（右）模拟框被划分为域，每个域中的原子被分配到不同的核心

上图中的域在空间上按体积分解。被称为 *ghost* 原子的原子副本在处理器之间交换，以说明位于不同内核上的原子之间的相互作用。每个核心并行计算分配给它的原子的相互作用，从而提高整体模拟速度。

为了解释位于不同核上的原子之间的相互作用，每个核使用一个壳构建其域，该壳容纳位于域边缘的粒子，并与其他核交换粒子的副本（称为幽灵原子），如下图所示图表：

<div align=center>
<img src='fig1_6.png'>
</div>

图 1.6 - 显示其壳（虚线框）的核心域和与相邻域共享的虚原子

所涉及的核心之间有两个通信阶段，在此详述：
- 在第一阶段，壳与相邻的核心交换幽灵原子坐标，以注册可以与域中包含的粒子相互作用的粒子。这些壳中的鬼原子本质上是其他域中原子的图像。
- 在第二阶段，在接下来的迭代中更新的原子位置用于确定是否有任何原子已移动到不同的域，如果是，则将原子坐标和运动学信息传达给适当的核心。在这一步之后，shell中的粒子将从内存中删除。

这种并行机制表明，随着内核数量的增加，内核之间的通信时间会成倍增加。由于内存和带宽的限制，并行化无法实现*N/P*的理想优化，其中*N*是原子数，*P*是处理器数，并导致亚线性加速。因此，对于给定的仿真系统，内核数量的增加最终会降低效率，并且存在提供最佳性能的最佳内核数量。

## 概括
本章介绍了 MD 的基础知识和常见的 MD 模拟实践，以帮助阐明 MD 代码中实现的物理和数学。在后面的章节讨论 LAMMPS 源代码时，这里讨论的概念将被引用并以源代码的形式进行解释。

在下一章中，您将了解 LAMMPS 输入脚本和通过 LAMMPS 命令执行 MD 仿真功能，以及标准 LAMMPS 代码库。


## 问题
1. 使用在所有方向都有周期性边界的模拟盒，如何生成由几层组成的金属板，使得板在 xy 平面上无限延伸，但在板的上方和下方容纳长真空？

2. 低温下的固体与高温下的气体之间的最佳表皮宽度应该如何比较？

3. 在一个包含均匀密度的溶质和溶剂分子的大型模拟盒子中，盒子中心的溶质分子的对势能如何随周期性或非周期性边界而变化（假设对势截止短于任何模拟盒边长的一半）？

4. 给定一个均匀的金属纳米晶体，如何建立子域和鬼原子？